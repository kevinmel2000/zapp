package service

import (
	"{{PackageName}}/dao"
	model "{{PackageName}}/model"
	log "{{PackageName}}/shared/logger"
	"{{PackageName}}/shared/utils"
)

// IUserService is
type IUserService interface {
	IGuestService
	IsAccessable(sc model.ServiceContext, req model.IsAccessableRequest) bool
	GetBasicUserInfo(sc model.ServiceContext, req model.GetBasicUserInfoRequest) *model.GetBasicUserInfoResponse
	UpdateBasicUserInfo(sc model.ServiceContext, req model.UpdateBasicUserInfoRequest) (*model.UpdateBasicUserInfoResponse, error)
	UpdatePassword(sc model.ServiceContext, req model.UpdatePasswordRequest) (*model.UpdatePasswordResponse, error)
	GetAllUserSpace(sc model.ServiceContext, req model.GetAllBasicRequest) ([]model.UserSpace, uint64)
	GetAllPermission(sc model.ServiceContext, req model.GetAllBasicRequest) (*model.GetAllPermissionResponse, uint64)
}

// UserService is
type UserService struct {
	GuestService
	Space          dao.ISpaceDao
	UserSpace      dao.IUserSpaceDao
	UserPermission dao.IUserPermissionDao
}

// IsAccessable is
func (o *UserService) IsAccessable(sc model.ServiceContext, req model.IsAccessableRequest) bool {
	userID, _ := o.getUserIDFromServiceContext(sc)

	up := o.UserPermission.GetUserPermission(o.Trx.GetDB(false), userID, req.SpaceID, req.MethodEndpoint)

	return up != nil
}

// GetBasicUserInfo is
func (o *UserService) GetBasicUserInfo(sc model.ServiceContext, req model.GetBasicUserInfoRequest) *model.GetBasicUserInfoResponse {

	userID, _ := o.getUserIDFromServiceContext(sc)

	bu := o.User.GetOneByID(o.Trx.GetDB(false), userID)

	response := model.GetBasicUserInfoResponse{
		User: bu,
	}

	return &response
}

// UpdateBasicUserInfo is
func (o *UserService) UpdateBasicUserInfo(sc model.ServiceContext, req model.UpdateBasicUserInfoRequest) (*model.UpdateBasicUserInfoResponse, error) {
	userID, _ := o.getUserIDFromServiceContext(sc)

	tx := o.Trx.GetDB(true)

	bu := o.User.GetOneByID(tx, userID)

	bu.Address = req.Address
	bu.Firstname = req.Firstname
	bu.Lastname = req.Lastname
	bu.Phone = req.Phone

	o.User.Update(tx, bu)

	response := model.UpdateBasicUserInfoResponse{}

	o.Trx.CommitTransaction(tx)

	return &response, nil
}

// UpdatePassword is
func (o *UserService) UpdatePassword(sc model.ServiceContext, req model.UpdatePasswordRequest) (*model.UpdatePasswordResponse, error) {

	userID, logInfo := o.getUserIDFromServiceContext(sc)

	tx := o.Trx.GetDB(true)

	bu := o.User.GetOneByID(tx, userID)

	if !o.Password.IsValidPassword(req.OldPassword, bu.Password) {
		log.GetLog().Error(logInfo, "Old Password does not match")
		o.Trx.RollbackTransaction(tx)
		return nil, utils.PrintError(model.ConstErrorUnExistingEmailAddress, "Old Password does not match ")
	}

	bu.Password = o.Password.GenerateHashPassword(req.NewPassword)

	o.User.Update(tx, bu)

	o.Trx.CommitTransaction(tx)

	return nil, nil
}

// GetAllUserSpace is
func (o *UserService) GetAllUserSpace(sc model.ServiceContext, req model.GetAllBasicRequest) ([]model.UserSpace, uint64) {
	return o.UserSpace.GetAll(o.Trx.GetDB(false), req)
}

// GetAllPermission is
func (o *UserService) GetAllPermission(sc model.ServiceContext, req model.GetAllBasicRequest) (*model.GetAllPermissionResponse, uint64) {

	// userID, logInfo := o.getUserIDFromServiceContext(sc)

	return nil, 0
}

func (o *UserService) getUserIDFromServiceContext(sc model.ServiceContext) (string, interface{}) {
	logInfo := sc["logInfo"]
	userIDInterface, ok := sc["user.id"]
	if !ok {
		log.GetLog().Panic(logInfo, "user.id not setup yet")
	}

	userID := userIDInterface.(string)
	return userID, logInfo
}
