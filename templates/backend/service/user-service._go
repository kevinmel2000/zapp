package service

import (
	"fmt"

	"{{PackagePath}}/server/model"
	"{{PackagePath}}/server/repository"
	"{{PackagePath}}/server/shared/utils"
	"{{PackagePath}}/server/shared/log"
	"{{PackagePath}}/server/shared/token"
	"{{PackagePath}}/server/shared/transaction"	
)

// ISystemUserService is
type ISystemUserService interface {
	Login(ctx map[string]interface{}, dto model.LoginSystemUserRequest) (string, error)
	ValidateLoginToken(ctx map[string]interface{}, token string) interface{}
	Register(ctx map[string]interface{}, dto model.RegisterSystemUserRequest) error
	HasAccess(extendData map[string]interface{}, accessName string) bool
}

// GetSystemUserID is
func GetSystemUserID(ctx map[string]interface{}) string {

	userIDIntf, okHaveSystemUserID := ctx["userID"]
	if !okHaveSystemUserID {
		log.GetLog().Fatal(ctx, "Does not have userID")
	}

	userID, okCast2 := userIDIntf.(string)
	if !okCast2 {
		log.GetLog().Fatal(ctx, "userID cannot cast to string")
	}

	return userID
}

// SystemUserService is
type SystemUserService struct {
	trx            transaction.ITransaction
	jwt            *token.Jwt
	systemUserRepository repository.ISystemUserRepository
}

// NewSystemUserService is
func NewSystemUserService(trx transaction.ITransaction, jwt *token.Jwt, systemUserRepository repository.ISystemUserRepository) *SystemUserService {
	return &SystemUserService{
		trx:            trx,
		jwt:            jwt,
		systemUserRepository: systemUserRepository,
	}
}

// Login is
func (u *SystemUserService) Login(ctx map[string]interface{}, dto model.LoginSystemUserRequest) (string, error) {
	ctx["trx"] = u.trx.GetDB(false)
	defer delete(ctx, "trx")

	existingSystemUser := u.systemUserRepository.GetByEmail(ctx, dto.Email)
	if existingSystemUser == nil {
		return "", fmt.Errorf("SystemUser not exist or wrong password 1")
	}

	if !utils.IsValidPassword(dto.Password, existingSystemUser.Password) {
		return "", fmt.Errorf("SystemUser not exist or wrong password %v != %v", dto.Password, existingSystemUser.Password)
	}

	extendData := map[string]interface{}{
		"userID": existingSystemUser.ID,
		"role":   existingSystemUser.Role,
		"name":   existingSystemUser.Name,
	}

	token := u.jwt.GenerateToken("LOGIN", "INTERNAL", "USER", extendData, 24)

	return token, nil
}

// ValidateLoginToken is
func (u *SystemUserService) ValidateLoginToken(ctx map[string]interface{}, loginToken string) interface{} {

	jwtObject := u.jwt.ValidateToken("LOGIN", loginToken)
	if jwtObject == nil {
		return nil
	}

	return jwtObject.ExtendData
}

// Register is
func (u *SystemUserService) Register(ctx map[string]interface{}, dto model.RegisterSystemUserRequest) error {

	ctx["trx"] = u.trx.GetDB(true)
	defer delete(ctx, "trx")
	defer u.trx.RollbackOnException(ctx)

	if existingSystemUser := u.systemUserRepository.GetByEmail(ctx, dto.Email); existingSystemUser != nil {
		u.trx.Rollback(ctx)
		return fmt.Errorf("Email %v already exist", dto.Email)
	}

	var obj model.SystemUser

	obj.ID = utils.GetUUID()
	obj.Name = dto.Name
	obj.Email = dto.Email
	obj.Password = utils.GenerateHashPassword(dto.Password)
	obj.Role = "USER"	
	u.systemUserRepository.Create(ctx, &obj)

	u.trx.Commit(ctx)

	return nil
}

// HasAccess is
func (u *SystemUserService) HasAccess(extendData map[string]interface{}, accessName string) bool {

	// if userID == "df9d6646-513d-47d6-a9a0-600a321f5f0b" && accessName == "OUTLET" {
	// 	return true
	// }

	// if userID == "f759b3d7-f730-400c-8877-e86c3168f8ea" && accessName == "MENUGROUP" {
	// 	return true
	// }

	// if userID == "0bd8fe85-f822-48ce-a3e4-1f0d39c40880" && accessName == "MENUITEM" {
	// 	return true
	// }

	return true

}
