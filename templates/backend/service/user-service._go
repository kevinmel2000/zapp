package service

import (
	"fmt"

	"{{PackagePath}}/server/model"
	"{{PackagePath}}/server/repository"
	"{{PackagePath}}/server/shared/utils"
	"{{PackagePath}}/server/shared/log"
	"{{PackagePath}}/server/shared/token"
	"{{PackagePath}}/server/shared/transaction"	
)

// IUserSystemService is
type IUserSystemService interface {
	Login(ctx map[string]interface{}, dto model.LoginUserSystemRequest) (string, error)
	ValidateLoginToken(ctx map[string]interface{}, token string) interface{}
	Register(ctx map[string]interface{}, dto model.RegisterUserSystemRequest) error
	HasAccess(extendData map[string]interface{}, accessName string) bool
}

// GetUserSystemID is
func GetUserSystemID(ctx map[string]interface{}) string {

	userIDIntf, okHaveUserSystemID := ctx["userID"]
	if !okHaveUserSystemID {
		log.GetLog().Fatal(ctx, "Does not have userID")
	}

	userID, okCast2 := userIDIntf.(string)
	if !okCast2 {
		log.GetLog().Fatal(ctx, "userID cannot cast to string")
	}

	return userID
}

// UserSystemService is
type UserSystemService struct {
	trx            transaction.ITransaction
	jwt            *token.Jwt
	userSystemRepository repository.IUserSystemRepository
}

// NewUserSystemService is
func NewUserSystemService(trx transaction.ITransaction, jwt *token.Jwt, userSystemRepository repository.IUserSystemRepository) *UserSystemService {
	return &UserSystemService{
		trx:            trx,
		jwt:            jwt,
		userSystemRepository: userSystemRepository,
	}
}

// Login is
func (u *UserSystemService) Login(ctx map[string]interface{}, dto model.LoginUserSystemRequest) (string, error) {
	ctx["trx"] = u.trx.GetDB(false)
	defer delete(ctx, "trx")

	existingUserSystem := u.userSystemRepository.GetByEmail(ctx, dto.Email)
	if existingUserSystem == nil {
		return "", fmt.Errorf("UserSystem not exist or wrong password 1")
	}

	if !utils.IsValidPassword(dto.Password, existingUserSystem.Password) {
		return "", fmt.Errorf("UserSystem not exist or wrong password %v != %v", dto.Password, existingUserSystem.Password)
	}

	extendData := map[string]interface{}{
		"userID": existingUserSystem.ID,
		"role":   existingUserSystem.Role,
		"name":   existingUserSystem.Name,
	}

	token := u.jwt.GenerateToken("LOGIN", "INTERNAL", "USER", extendData, 24)

	return token, nil
}

// ValidateLoginToken is
func (u *UserSystemService) ValidateLoginToken(ctx map[string]interface{}, loginToken string) interface{} {

	jwtObject := u.jwt.ValidateToken("LOGIN", loginToken)
	if jwtObject == nil {
		return nil
	}

	return jwtObject.ExtendData
}

// Register is
func (u *UserSystemService) Register(ctx map[string]interface{}, dto model.RegisterUserSystemRequest) error {

	ctx["trx"] = u.trx.GetDB(true)
	defer delete(ctx, "trx")
	defer u.trx.RollbackOnException(ctx)

	if existingUserSystem := u.userSystemRepository.GetByEmail(ctx, dto.Email); existingUserSystem != nil {
		u.trx.Rollback(ctx)
		return fmt.Errorf("Email %v already exist", dto.Email)
	}

	var obj model.UserSystem

	obj.ID = utils.GetUUID()
	obj.Name = dto.Name
	obj.Email = dto.Email
	obj.Password = utils.GenerateHashPassword(dto.Password)
	obj.Role = "USER"	
	u.userSystemRepository.Create(ctx, &obj)

	u.trx.Commit(ctx)

	return nil
}

// HasAccess is
func (u *UserSystemService) HasAccess(extendData map[string]interface{}, accessName string) bool {

	// if userID == "df9d6646-513d-47d6-a9a0-600a321f5f0b" && accessName == "OUTLET" {
	// 	return true
	// }

	// if userID == "f759b3d7-f730-400c-8877-e86c3168f8ea" && accessName == "MENUGROUP" {
	// 	return true
	// }

	// if userID == "0bd8fe85-f822-48ce-a3e4-1f0d39c40880" && accessName == "MENUITEM" {
	// 	return true
	// }

	return true

}
