package log

import (
	"fmt"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/rifflock/lfshook"
	"github.com/sirupsen/logrus"

	rotatelogs "github.com/lestrrat-go/file-rotatelogs"
)

var defaultLogger logrusImpl
var defaultLoggerOnce sync.Once

// ILogger is
type ILogger interface {
	Debug(description string, args ...interface{}) string
	Info(description string, args ...interface{}) string
	Warn(description string, args ...interface{}) string
	Error(description string, args ...interface{}) string
	Fatal(description string, args ...interface{}) string
	Panic(description string, args ...interface{}) string
	WithFile(path, appsName string, maxAge int)
}

// LogrusImpl is
type logrusImpl struct {
	theLogger *logrus.Logger
	useFile   bool
}

// GetLog is
func GetLog() ILogger {
	defaultLoggerOnce.Do(func() {
		defaultLogger = logrusImpl{theLogger: logrus.New()}
		defaultLogger.useFile = false
		defaultLogger.theLogger.SetFormatter(&logrus.JSONFormatter{
			TimestampFormat: "0102 150405.000",
		})
	})
	return &defaultLogger
}

// WithFile is command to state the log will printing to files
// the rolling log file will put in logs/ directory
//
// filename is just a name of log file without any extension
//
// maxAge is age (in days) of the logs file before it gets purged from the file system
func (l *logrusImpl) WithFile(path, appsName string, maxAge int) {

	if !l.useFile {

		if maxAge <= 0 {
			panic("maxAge should > 0")
		}

		writer, _ := rotatelogs.New(
			fmt.Sprintf("%s/logs/%s.log.%s", path, appsName, "%Y%m%d"),
			rotatelogs.WithLinkName(fmt.Sprintf("%s/%s.log", path, appsName)),
			rotatelogs.WithMaxAge(time.Duration(maxAge*24)*time.Hour),
			rotatelogs.WithRotationTime(time.Duration(1*24)*time.Hour),
		)		

		defaultLogger.theLogger.AddHook(lfshook.NewHook(
			lfshook.WriterMap{
				logrus.InfoLevel:  writer,
				logrus.WarnLevel:  writer,
				logrus.ErrorLevel: writer,
				logrus.DebugLevel: writer,
				logrus.FatalLevel: writer,
				logrus.PanicLevel: writer,				
			},
			defaultLogger.theLogger.Formatter,
		))

		l.useFile = true
	}
}

func (l *logrusImpl) getLogEntry() *logrus.Entry {	
	pc, _, _, _ := runtime.Caller(2)

	funcName := runtime.FuncForPC(pc).Name()
	x := strings.LastIndex(funcName, "/")
	return l.theLogger.WithField("func", funcName[x+1:])
}

// Debug is
func (l *logrusImpl) Debug(description string, args ...interface{}) string {
	message := fmt.Sprintf(description, args...)
	l.getLogEntry().Debug(message)
	return message
}

// Info is
func (l *logrusImpl) Info(description string, args ...interface{}) string {
	message := fmt.Sprintf(description, args...)
	l.getLogEntry().Info(message)
	return message
}

// Warn is
func (l *logrusImpl) Warn(description string, args ...interface{}) string {
	message := fmt.Sprintf(description, args...)
	l.getLogEntry().Warn(message)
	return message
}

// Error is
func (l *logrusImpl) Error(description string, args ...interface{}) string {
	message := fmt.Sprintf(description, args...)
	l.getLogEntry().Error(message)
	return message
}

// Fatal is
func (l *logrusImpl) Fatal(description string, args ...interface{}) string {
	message := fmt.Sprintf(description, args...)
	l.getLogEntry().Fatal(message)
	return message
}

// Panic is
func (l *logrusImpl) Panic(description string, args ...interface{}) string {
	message := fmt.Sprintf(description, args...)
	l.getLogEntry().Panic(message)
	return message
}
