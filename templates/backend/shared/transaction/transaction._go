package transaction

import (
	"github.com/jinzhu/gorm"
)

// ITransaction is
type ITransaction interface {
	GetDB(withTransaction bool) *gorm.DB // this is for get the database with two mode with transaction or without transaction
	Commit(db interface{})               // commit the transaction
	Rollback(db interface{})             // rollback transaction
	RollbackOnException(db interface{})  // for emergency rollback
}

// GormTransactionDB is
type GormTransactionDB struct {
	DB *gorm.DB
}

// ExtractDB is
func ExtractDB(db interface{}) *gorm.DB {
	dbx, ok := db.(*gorm.DB)
	if !ok {
		return nil
	}
	return dbx
}

// NewGormTransactionDB is
func NewGormTransactionDB(db *gorm.DB) *GormTransactionDB {
	return &GormTransactionDB{db}
}

// GetDB is
func (g *GormTransactionDB) GetDB(withTransaction bool) *gorm.DB {
	if withTransaction {
		return g.DB.Begin()
	}
	return g.DB
}

// Commit is
func (g *GormTransactionDB) Commit(db interface{}) {
	ExtractDB(db).Commit()
}

// Rollback is
func (g *GormTransactionDB) Rollback(db interface{}) {
	ExtractDB(db).Rollback()
}

// RollbackOnException is common handler for rollback the transaction
// to avoid database lock when something goes wrong in transaction state
// use with defer right after we call GetDB(true)
func (g *GormTransactionDB) RollbackOnException(db interface{}) {

	trx := ExtractDB(db)

	// catch the error
	if err := recover(); err != nil {

		// rollback it!
		trx.Rollback()

		// repanic so we can get where it happen in log!
		// log.GetLog().Panic(ctx, "%v", err)
	}
}
